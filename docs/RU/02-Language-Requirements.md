# Embedded FSM SDK — Требования к языку (Черновик v2.0)

Область применения: DSL + SDK (компиляторный инструментарий) + расширение VS Code + Web IDE/сервис  
Лицензионное намерение: MIT (спецификация + эталонная реализация)

Этот документ определяет полные требования к FSM-Lang на уровне языка и системы.
Он устанавливает функциональные, семантические, инструментальные и промышленные ограничения.

Этот документ является нормативным.

---

## 0) Определения

- **FSM**: Конечный автомат.
- **HSM**: Иерархический конечный автомат с формально определённой семантикой входа/выхода.
- **Orthogonal Region**: Параллельная область состояний, активная одновременно внутри составного состояния.
- **Pseudo-State**: Структурный узел состояния без контекста выполнения (choice, junction, history, initial, final).
- **LCA**: Наименьший общий предок в иерархии состояний.
- **Event Payload**: Типизированные, ограниченные данные, прикреплённые к событию.
- **Context**: Типизированное персистентное состояние автомата.
- **Target Profile**: Ограничения компиляции/выполнения, специфичные для платформы.
- **Deterministic Model**: Модель с ровно одним определённым путём выполнения на событие в каждой конфигурации.
- **Industrial Completeness**: Покрытие всех конструкций, необходимых для промышленного моделирования statechart.

---

# 1) Цели продукта (Нефункциональные)

## G1. Формальный детерминизм

- Семантика выполнения ДОЛЖНА быть полностью определена.
- Выбор перехода ДОЛЖЕН быть детерминированным.
- Разрешение конфликтов в иерархических и параллельных состояниях ДОЛЖНО быть формально определено.
- Неопределённое поведение НЕ ДОЛЖНО существовать.

## G2. Ограничения уровня embedded

- Отсутствие обязательного динамического выделения памяти.
- Ограниченная модель памяти.
- Ограниченная очередь событий.
- Предсказуемая стоимость выполнения на одну диспетчеризацию.
- Детерминированная генерация кода.

## G3. Промышленная полнота

Язык ДОЛЖЕН поддерживать полный набор возможностей, необходимых для промышленного моделирования иерархических конечных автоматов:

- Иерархические состояния (произвольная глубина вложенности)
- Ортогональные (параллельные) области
- Начальные псевдосостояния
- Финальные состояния
- Псевдосостояния выбора
- Псевдосостояния соединения
- Поверхностную историю
- Глубокую историю
- Внешние переходы
- Внутренние переходы
- Локальные переходы
- Явный приоритет переходов
- Guard-выражения
- Отложенные события
- Типизированную полезную нагрузку события
- Типизированный контекст автомата
- Таймеры
- Генерацию событий
- Явную отмену событий
- Статическое обнаружение недетерминизма
- Статический анализ достижимости

Целевые профили МОГУТ ограничивать использование, но определение языка ДОЛЖНО включать все конструкции.

## G4. Единый источник истины

- Каноническая семантическая модель ДОЛЖНА быть независима от layout.
- DSL ДОЛЖЕН быть без потерь преобразуем в каноническое представление.
- Модель ДОЛЖНА быть версионируемой.

## G5. Полнота инструментария

Жизненный цикл ДОЛЖЕН поддерживать:

Parse → Validate → Analyze → Compile → Simulate → Debug → Generate → Export.

---

# 2) Требования к структурной части языка

## 2.1 Определение автомата

Язык ДОЛЖЕН определять:

- Объявление автомата
- Объявление контекста (типизированного)
- Объявления событий (типизированная полезная нагрузка)
- Иерархию состояний
- Объявления областей
- Начальные состояния для каждой области
- Финальные состояния
- Псевдосостояния

## 2.2 Иерархическая модель

- Неограниченная глубина вложенности.
- Каждое составное состояние может содержать одну или более ортогональных областей.
- Каждая область ДОЛЖНА определять ровно одно начальное состояние.

## 2.3 Ортогональные области

- Области выполняются параллельно внутри составного состояния.
- Семантика диспетчеризации событий между областями ДОЛЖНА быть определена.
- Разрешение конфликтов между областями ДОЛЖНО быть детерминированным.

## 2.4 Семантика истории

Язык ДОЛЖЕН поддерживать:

- Поверхностную историю (восстановление прямого потомка)
- Глубокую историю (восстановление полного поддерева)
- Определённое поведение сброса, если история отсутствует

---

# 3) Требования к модели переходов

## 3.1 Типы переходов

Язык ДОЛЖЕН поддерживать:

- Внешний переход
- Внутренний переход
- Локальный переход
- Переход завершения
- Временной переход

## 3.2 Семантика guard

- Guard-выражения ДОЛЖНЫ быть без побочных эффектов.
- Guard-выражения ДОЛЖНЫ быть детерминированными.
- Guard-выражения ДОЛЖНЫ вычисляться до выполнения exit-действий.
- Перекрытие guard-условий ДОЛЖНО быть статически анализируемым.

## 3.3 Алгоритм выбора перехода

Язык ДОЛЖЕН формально определять:

1. Порядок диспетчеризации событий.
2. Обнаружение кандидатных переходов (иерархически).
3. Разрешение приоритетов.
4. Порядок вычисления guard-условий.
5. Разрешение конфликтов в иерархии.
6. Разрешение конфликтов между параллельными областями.

Неоднозначность ДОЛЖНА быть ошибкой компиляции.

## 3.4 Порядок выполнения LCA

При внешнем переходе:

1. Выполнение exit-действий от исходного состояния до (но не включая) LCA.
2. Выполнение действий перехода.
3. Выполнение entry-действий от LCA до целевого состояния.

Порядок выполнения ДОЛЖЕН быть детерминированным.

---

# 4) Требования к модели событий

## 4.1 Объявление события

- События ДОЛЖНЫ быть явно объявлены.
- События МОГУТ определять типизированные поля полезной нагрузки.
- Полезная нагрузка ДОЛЖНА быть статически типизированной.
- Полезная нагрузка ДОЛЖНА быть ограниченной (безопасной для embedded).

## 4.2 Очередь событий

- Очередь ДОЛЖНА быть ограниченной.
- Политика переполнения ДОЛЖНА быть настраиваемой.
- Семантика обработки (drain) ДОЛЖНА быть определена.
- Порядок событий ДОЛЖЕН быть FIFO, если не указано иное.

## 4.3 Отложенные события

- Состояния МОГУТ откладывать события.
- Отложенные события ДОЛЖНЫ помещаться в очередь.
- Семантика освобождения ДОЛЖНА быть определена.
- Недопустимые циклы откладывания ДОЛЖНЫ обнаруживаться.

## 4.4 Генерация событий

- Переходы и действия МОГУТ генерировать события.
- Сгенерированные события ДОЛЖНЫ помещаться в очередь.
- Рекурсивная диспетчеризация событий ДОЛЖНА быть ограничена.

---

# 5) Требования к модели таймеров

- Таймеры ДОЛЖНЫ генерировать события.
- Жизненный цикл таймера ДОЛЖЕН быть связан с жизненным циклом состояния, если явно не указано иное.
- Отмена таймера ДОЛЖНА быть детерминированной.
- Семантика времени в симуляции ДОЛЖНА соответствовать embedded-семантике.

---

# 6) Требования к модели контекста

- Контекст автомата ДОЛЖЕН быть статически типизирован.
- Размещение памяти контекста ДОЛЖНО быть предсказуемым.
- Динамическое добавление полей запрещено.
- Guard-выражения МОГУТ ссылаться на поля контекста.
- Действия МОГУТ изменять поля контекста.

---

# 7) Требования к языку выражений

- Ограниченная грамматика выражений.
- Отсутствие произвольного выполнения кода.
- Отсутствие рефлексии.
- Отсутствие динамического вычисления.
- Детерминированный порядок вычисления.
- Guard-выражения без побочных эффектов.

---

# 8) Требования к статическому анализу

Валидатор ДОЛЖЕН обнаруживать:

- Отсутствующие начальные состояния
- Несколько начальных состояний в области
- Недостижимые состояния
- Мёртвые переходы
- Недетерминированные переходы
- Неоднозначность перекрытия guard-условий
- Некорректные иерархические переходы
- Некорректные LCA-переходы
- Недопустимую структуру областей
- Некорректное использование истории
- Циклы отложенных событий
- Некорректное использование таймеров
- Нарушения целевого профиля

Диагностика ДОЛЖНА включать:

- Стабильный код диагностики
- Уровень серьёзности
- Локацию
- Детерминированное сообщение

---

# 9) Требования к IR

- Детерминированное преобразование из DSL в IR.
- IR ДОЛЖЕН сохранять семантическую эквивалентность.
- IR ДОЛЖЕН быть стабильным между сборками.

---

# 10) Требования к генерации кода

Сгенерированный код ДОЛЖЕН:

- Сохранять семантическое поведение.
- Сохранять иерархическую семантику.
- Поддерживать параллельные области.
- Поддерживать историю.
- Поддерживать ограниченное выполнение.
- Позволять конфигурацию без использования кучи.
- Обеспечивать детерминированную диспетчеризацию.

---

# 11) Требования к симуляции и отладке

Симулятор ДОЛЖЕН поддерживать:

- Пошаговое выполнение
- Непрерывное выполнение
- Точки останова (вход в состояние, переход)
- Инъекцию событий
- Инспекцию контекста
- Инспекцию состояний параллельных областей
- Детерминированное воспроизведение

Трассировка ДОЛЖНА обеспечивать полное воспроизведение выполнения.

---

# 12) Критерии соответствия

Язык считается соответствующим, если:

- Все промышленные конструкции определены.
- Детерминизм формально обеспечен.
- Не существует неопределённого поведения.
- Статический анализ предотвращает неоднозначность.
- Каноническая модель проходит round-trip без потери семантики.
- Сгенерированный код сохраняет семантику выполнения.

---

# 13) Явно вне области применения

- Вероятностные конечные автоматы
- Распределённая синхронизация между несколькими узлами
- Интеграция формальной проверки модели (может быть добавлена позже)
- Выполнение недетерминированных автоматов
